using Microsoft.AspNetCore.Cryptography.KeyDerivation;
using System.Net;
using System.Security.Cryptography;

namespace Edi.AspNetCore.Utils;

/// <summary>
/// Provides security utilities for ASP.NET Core applications.
/// </summary>
public class SecurityHelper
{
    /// <summary>
    /// Sanitizes a URL by validating it against common security threats such as open redirects,
    /// localhost access, and private IP addresses.
    /// </summary>
    /// <param name="rawUrl">The raw URL to sterilize.</param>
    /// <returns>
    /// The sanitized URL if valid; otherwise, returns "#" for invalid or potentially dangerous URLs.
    /// </returns>
    public static string SterilizeLink(string rawUrl)
    {
        bool IsUnderLocalSlash()
        {
            // Allows "/" or "/foo" but not "//" or "/\".
            if (rawUrl[0] == '/')
            {
                // url is exactly "/"
                if (rawUrl.Length == 1)
                {
                    return true;
                }

                // url doesn't start with "//" or "/\"
                return rawUrl[1] is not '/' and not '\\';
            }

            return false;
        }

        string invalidReturn = "#";
        if (string.IsNullOrWhiteSpace(rawUrl))
        {
            return invalidReturn;
        }

        if (!rawUrl.IsValidUrl())
        {
            return IsUnderLocalSlash() ? rawUrl : invalidReturn;
        }

        var uri = new Uri(rawUrl);
        if (uri.IsLoopback)
        {
            // localhost, 127.0.0.1
            return invalidReturn;
        }

        if (uri.HostNameType == UriHostNameType.IPv4)
        {
            // Disallow LAN IP (e.g. 192.168.0.1, 10.0.0.1)
            if (IsPrivateIP(uri.Host))
            {
                return invalidReturn;
            }
        }

        return rawUrl;
    }

    /// <summary>
    /// Test an IPv4 address is LAN or not.
    /// </summary>
    /// <param name="ip">IPv4 address</param>
    /// <returns>bool</returns>
    public static bool IsPrivateIP(string ip) => IPAddress.Parse(ip).GetAddressBytes() switch
    {
        // Regex.IsMatch(ip, @"(^127\.)|(^10\.)|(^172\.1[6-9]\.)|(^172\.2[0-9]\.)|(^172\.3[0-1]\.)|(^192\.168\.)")
        // Regex has bad performance, this is better

        var x when x[0] is 192 && x[1] is 168 => true,
        var x when x[0] is 10 => true,
        var x when x[0] is 127 => true,
        var x when x[0] is 172 && x[1] is >= 16 and <= 31 => true,
        _ => false
    };

    /// <summary>
    /// Hashes a password using PBKDF2 with the specified parameters.
    /// </summary>
    /// <param name="clearPassword">The plain-text password to hash.</param>
    /// <param name="saltBase64">A Base64-encoded salt, e.g. generated by <see cref="GenerateSalt"/>.</param>
    /// <param name="prf">The pseudo-random function to use. Defaults to <see cref="KeyDerivationPrf.HMACSHA256"/>.</param>
    /// <param name="iterationCount">The number of iterations. Higher values increase security but reduce performance. Defaults to 100,000.</param>
    /// <param name="numBytesRequested">The desired length of the derived key in bytes. Defaults to 32 (256 bits).</param>
    /// <returns>A Base64-encoded string of the derived key.</returns>
    /// <exception cref="ArgumentNullException">Thrown when <paramref name="clearPassword"/> or <paramref name="saltBase64"/> is null.</exception>
    /// <exception cref="ArgumentException">Thrown when <paramref name="clearPassword"/> or <paramref name="saltBase64"/> is empty or whitespace.</exception>
    /// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="iterationCount"/> or <paramref name="numBytesRequested"/> is less than or equal to zero.</exception>
    public static string HashPassword(
        string clearPassword,
        string saltBase64,
        KeyDerivationPrf prf = KeyDerivationPrf.HMACSHA256,
        int iterationCount = 100000,
        int numBytesRequested = 256 / 8)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(clearPassword);
        ArgumentException.ThrowIfNullOrWhiteSpace(saltBase64);
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(iterationCount);
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(numBytesRequested);

        var salt = Convert.FromBase64String(saltBase64);

        return Convert.ToBase64String(KeyDerivation.Pbkdf2(
            password: clearPassword,
            salt: salt,
            prf: prf,
            iterationCount: iterationCount,
            numBytesRequested: numBytesRequested));
    }

    /// <summary>
    /// Generates a cryptographically strong random salt encoded as a Base64 string.
    /// </summary>
    /// <param name="size">The number of random bytes to generate. Defaults to 16 (128 bits).</param>
    /// <returns>A Base64-encoded string representation of the generated salt.</returns>
    /// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="size"/> is less than or equal to zero.</exception>
    public static string GenerateSalt(int size = 16)
    {
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(size);
        return Convert.ToBase64String(RandomNumberGenerator.GetBytes(size));
    }
}
